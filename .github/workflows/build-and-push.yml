name: Build, Push and Deploy

on:
  push:
    branches: [ main ]
    paths:
      - 'frontend/**'
      - '*/app/**'
      - '**/Dockerfile'
      - '.github/workflows/build-and-push.yml'
      - 'deploy/**'
  workflow_dispatch:
    inputs:
      services:
        description: "Space-separated services to deploy (e.g., frontend account_service)"
        required: false
        default: "frontend account_service category_service expense_service income_service user_service"

env:
  REGISTRY: ${{ secrets.REGISTRY || 'docker.io' }}
  IMAGE_PREFIX: ${{ secrets.IMAGE_PREFIX || github.repository }}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
      id-token: write

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Log in to Docker Hub
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ secrets.DOCKER_USERNAME }}
          password: ${{ secrets.DOCKER_PASSWORD }}

      - name: Compute tags
        id: vars
        run: |
          SHA=${GITHUB_SHA::7}
          echo "sha=$SHA" >> $GITHUB_OUTPUT
          echo "ts=$(date +%Y%m%d%H%M%S)" >> $GITHUB_OUTPUT

      - name: Build and push images
        uses: nick-fields/retry@v3
        with:
          timeout_minutes: 30
          max_attempts: 2
          command: |
            set -euo pipefail
            for svc in frontend account_service category_service currency_service debt_service expense_service goals_service income_service pdf_parser_service recurring_service user_service; do
              context="${svc}"
              # Derive dockerfile path
              if [ "$svc" = "frontend" ]; then
                dockerfile="frontend/Dockerfile"
              else
                # prefer Dockerfile, fallback to dockerfile
                if [ -f "$svc/Dockerfile" ]; then dockerfile="$svc/Dockerfile"; else dockerfile="$svc/dockerfile"; fi
              fi

              if [ ! -f "$dockerfile" ]; then
                echo "Skip $svc (no Dockerfile)"
                continue
              fi

              image="${{ env.REGISTRY }}/${{ secrets.DOCKER_USERNAME }}/$svc"
              tags="\
                --tag $image:latest \
                --tag $image:${{ steps.vars.outputs.sha }} \
                --tag $image:${{ steps.vars.outputs.ts }} \
              "

              echo "Building $svc using $dockerfile -> $image"
              docker buildx build \
                --platform linux/amd64 \
                -f "$dockerfile" "$context" \
                --push $tags
            done

      - name: Setup SSH
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: ${{ secrets.HZ_SSH_KEY }}

      - name: Add host key
        run: |
          mkdir -p ~/.ssh
          ssh-keyscan -H ${{ secrets.HZ_HOST }} >> ~/.ssh/known_hosts

      - name: Deploy to Hetzner
        env:
          SERVICES: ${{ github.event.inputs.services }}
        run: |
          set -euo pipefail
          HOST=${{ secrets.HZ_HOST }}
          USER=${{ secrets.HZ_USER || 'root' }}

          # default set of services if not provided
          if [ -z "${SERVICES:-}" ]; then
            SERVICES="frontend account_service category_service currency_service debt_service expense_service goals_service income_service pdf_parser_service recurring_service user_service"
          fi

          # Remote script: pull latest images and recreate containers via compose
          ssh -o StrictHostKeyChecking=no "$USER@$HOST" bash -s <<'EOS'
            set -euo pipefail
            cd ~/app || mkdir -p ~/app && cd ~/app

            # Expect a docker-compose.yml in this directory configured to use images like REGISTRY/IMAGE_PREFIX/<svc>:latest
            echo "Pulling latest images..."
            docker compose pull
            echo "Recreating services: $SERVICES"
            docker compose up -d $SERVICES

            echo "Pruning old images..."
            docker image prune -f || true
          EOS
