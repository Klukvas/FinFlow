name: Deploy via SSH and Compose
description: SSH to host, write compose and env, pull images, and recreate services

inputs:
  host:
    description: Target host
    required: true
  user:
    description: SSH user
    required: true
    default: root
  ssh-private-key:
    description: SSH private key
    required: true
  registry:
    description: Registry for images
    required: true
  image-prefix:
    description: Image namespace/prefix
    required: true
  db-host:
    description: Database host
    required: true
  db-port:
    description: Database port
    required: true
    default: "5432"
  db-name:
    description: Database name
    required: true
  db-user:
    description: Database user
    required: true
  db-password:
    description: Database password
    required: true
  cors-origins:
    description: CORS allowed origins (comma-separated)
    required: false
    default: "http://localhost:3000,http://localhost:5173"
  services:
    description: Space-separated services to deploy
    required: true
    default: "caddy redis frontend account_service category_service currency_service debt_service expense_service goals_service income_service pdf_parser_service recurring_service user_service"

runs:
  using: "composite"
  steps:
    - name: Setup SSH
      uses: webfactory/ssh-agent@v0.9.0
      with:
        ssh-private-key: ${{ inputs['ssh-private-key'] }}

    - name: Add host key
      shell: bash
      run: |
        set -euo pipefail
        mkdir -p ~/.ssh
        ssh-keyscan -H "${{ inputs.host }}" >> ~/.ssh/known_hosts

    - name: Create deployment script
      shell: bash
      run: |
        cat > /tmp/deploy.sh <<'SCRIPT'
        set -euo pipefail
        mkdir -p ~/app
        cd ~/app

        # URL-encode the password for DATABASE_URL
        DB_PASSWORD_ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote_plus('$DB_PASSWORD'))")
        
        # Generate secrets if not already present in existing .env
        if [ -f .env ]; then
          source .env 2>/dev/null || true
        fi
        
        if [ -z "${SECRET_KEY:-}" ]; then
          SECRET_KEY=$(openssl rand -hex 32)
        fi
        
        if [ -z "${ALGORITHM:-}" ]; then
          ALGORITHM="HS256"
        fi
        
        if [ -z "${INTERNAL_SECRET_TOKEN:-}" ]; then
          INTERNAL_SECRET_TOKEN=$(openssl rand -hex 32)
        fi
        
        cat > .env <<ENVEOF
        REGISTRY=$REGISTRY
        IMAGE_PREFIX=$IMAGE_PREFIX
        DB_HOST=$DB_HOST
        DB_PORT=$DB_PORT
        DB_NAME=$DB_NAME
        DB_USER=$DB_USER
        DB_PASSWORD=$DB_PASSWORD
        DB_PASSWORD_ENCODED=$DB_PASSWORD_ENCODED
        CORS_ORIGINS=$CORS_ORIGINS
        cors_origins=$CORS_ORIGINS
        NODE_ENV=production
        SECRET_KEY=$SECRET_KEY
        ALGORITHM=$ALGORITHM
        INTERNAL_SECRET_TOKEN=$INTERNAL_SECRET_TOKEN
        ENVEOF

        # Use the docker-compose.yml from the deploy folder (already copied)
        # This ensures we use the standardized configuration from the repository
        echo "📋 Using docker-compose.yml from deploy folder..."
        
        # Verify the docker-compose.yml file exists
        if [ ! -f docker-compose.yml ]; then
          echo "❌ docker-compose.yml not found! Make sure it was copied from the deploy folder."
          exit 1
        fi

        # Verify Caddyfile exists (should be copied from deploy folder)
        if [ ! -f Caddyfile ]; then
          echo "❌ Caddyfile not found! Make sure it was copied from the deploy folder."
          exit 1
        fi
        
        # Create Caddyfile if it doesn't exist (fallback)
        if [ ! -f Caddyfile ]; then
          cat > Caddyfile <<'CADDYEOF'
        {
          auto_https disable_redirects
        }

        :80 {
          encode zstd gzip
          log

          # API routes - proxy to backend services
          handle_path /api/users/* {
            reverse_proxy user_service:8000
          }

          handle_path /api/categories/* {
            reverse_proxy category_service:8000
          }

          handle_path /api/expenses/* {
            reverse_proxy expense_service:8000
          }

          handle_path /api/income/* {
            reverse_proxy income_service:8000
          }

          handle_path /api/accounts/* {
            reverse_proxy account_service:8000
          }

          handle_path /api/currencies/* {
            reverse_proxy currency_service:8000
          }

          handle_path /api/debts/* {
            reverse_proxy debt_service:8000
          }

          handle_path /api/goals/* {
            reverse_proxy goals_service:8000
          }

          handle_path /api/recurring/* {
            reverse_proxy recurring_service:8000
          }

          handle_path /api/pdf/* {
            reverse_proxy pdf_parser_service:8000
          }

          # Frontend - SPA routing with fallback to index.html
          handle /* {
            reverse_proxy frontend:80 {
              header_up Host {host}
              header_up X-Real-IP {remote_host}
              header_up X-Forwarded-For {remote_host}
              header_up X-Forwarded-Proto {scheme}
            }
          }
        }
        CADDYEOF
        fi

        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📥 Pulling latest images..."
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        if docker compose pull ${SERVICES}; then
          echo "✅ Images pulled successfully"
        else
          echo "⚠️ Some images failed to pull"
        fi

        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "🔄 Recreating services: ${SERVICES}"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        if docker compose up -d ${SERVICES}; then
          echo "✅ Services started successfully"
        else
          echo "❌ Failed to start some services"
          exit 1
        fi

        echo ""
        echo "🧹 Cleaning up old images..."
        docker image prune -f || true

        echo ""
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "📊 Deployment Status"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        docker compose ps

        echo ""
        echo "✅ Deployment completed successfully!"
        SCRIPT

    - name: Deploy over SSH
      shell: bash
      env:
        HOST: ${{ inputs.host }}
        USER: ${{ inputs.user }}
        REGISTRY: ${{ inputs.registry }}
        IMAGE_PREFIX: ${{ inputs['image-prefix'] }}
        DB_HOST: ${{ inputs['db-host'] }}
        DB_PORT: ${{ inputs['db-port'] }}
        DB_NAME: ${{ inputs['db-name'] }}
        DB_USER: ${{ inputs['db-user'] }}
        DB_PASSWORD: ${{ inputs['db-password'] }}
        CORS_ORIGINS: ${{ inputs['cors-origins'] }}
        SERVICES: ${{ inputs.services }}
      run: |
        set -euo pipefail
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "🚀 Starting deployment process"
        echo "━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━"
        echo "Host: $HOST"
        echo "User: $USER"
        echo "Registry: $REGISTRY"
        echo "Services: ${SERVICES:-<empty>}"

        # Use default services if empty
        if [ -z "${SERVICES:-}" ]; then
          SERVICES="caddy redis frontend account_service category_service currency_service debt_service expense_service goals_service income_service pdf_parser_service recurring_service user_service"
          echo "Using default services: $SERVICES"
        fi

        echo ""
        echo "📦 Services to deploy: $SERVICES"
        echo ""

        # Transfer deployment script and docker-compose.yml
        scp /tmp/deploy.sh "$USER@$HOST:/tmp/deploy.sh"
        scp deploy/docker-compose.yml "$USER@$HOST:~/app/docker-compose.yml"
        scp deploy/Caddyfile "$USER@$HOST:~/app/Caddyfile"
        ssh -o StrictHostKeyChecking=no "$USER@$HOST" "export REGISTRY='$REGISTRY' IMAGE_PREFIX='$IMAGE_PREFIX' DB_HOST='$DB_HOST' DB_PORT='$DB_PORT' DB_NAME='$DB_NAME' DB_USER='$DB_USER' DB_PASSWORD='$DB_PASSWORD' CORS_ORIGINS='$CORS_ORIGINS' SERVICES='$SERVICES' && bash /tmp/deploy.sh"
